#! /usr/bin/env python

import numpy as np
import sys
import re
import matplotlib.pyplot as plt
import requests
from bs4 import BeautifulSoup as BS
import random
from datetime import datetime as dt


# In[2]:


def printlist ( mylist ):
    "Print a list element by element"
    for el in mylist:
        print(el)
    return None


# In[3]:


def help_title_section ():
    print("===========================================")
    print("================= H E L P =================")
    print("===========================================\n")
    return None


# In[4]:


def get_optgeom_orca (outputfile):
    "This function extracts the optimized (last one in output) from an ORCA output file"
    file = outputfile.split('.')
    file[1] = '_optimized.xyz'
    final_filename = ''.join(file) # make the final filename of xyz file
    
    # open output file, read, and close file
    with open(outputfile,"r") as input_file:
        input_string = input_file.read()
        input_file.close()
    
    # extract the last geometry from output file using rindex
    last_geo = input_string[input_string.rindex('CARTESIAN COORDINATES (ANGSTROEM)'):input_string.rindex('CARTESIAN COORDINATES (A.U.')-31].split()
    last_geo = list(last_geo)
    del last_geo[0:4]
    
    # initialist list, and make each set of "atom x y z" fields into lists
    list_geo = [[] for i in range(len(last_geo)//4)]
    for i in range(0,len(last_geo),4):
        j = i//4
        list_geo[j] = last_geo[i:i+4]
        
    for i in range(len(list_geo)):
        for k in range(3):
            list_geo[i][k] += "\t" # add a tab between xyz coordinates -> pretty!
        for j in range(1,4):
            if float(list_geo[i][j]) > 0:
                list_geo[i][j] = " " + list_geo[i][j] # add space to align coordinates on first number, and not on first symbol -> pretty!
                
    # add number of atoms and comment line
    nbofatoms = len(list_geo)
    list_geo.insert(0, ["Comment line"])
    list_geo.insert(0, [nbofatoms])
    
    with open(final_filename, "w") as output_file:
        for line in list_geo:
            output_file.write(''.join([str(el) for el in line]))
            output_file.write("\n")
        output_file.close()
        
    print("===============================================================")
    print('Optimized geometry written to {}'.format(final_filename))
    print("===============================================================")
    
    return


# In[5]:


def get_residues ( pdbcode ):
    print("Give the residues you want, separated by space:")
    residues = raw_input().split(" ")

    outputname = ["-".join(residues)]
    outputname.insert(0, pdbcode + "-")

    fetch_pdb(pdbcode)
    with open("{}.pdb".format(pdbcode), "r") as infile:
        readfile = infile.readlines()
        infile.close()

    element, x, y, z, res = ([] for i in range(5))

    for line in readfile:
        if line.startswith("ATOM") or line.startswith("HETATM"):
            element.append(line[76:78].strip())
            x.append(line[30:38].strip())
            y.append(line[38:46].strip())
            z.append(line[46:54].strip())
            res.append(("".join(line[21] + line[22:26])).replace(" ", ""))

    coord = [[] for i in range(len(x))]
    selection = []
    for i in range(len(x)):
        coord[i] = [element[i], x[i], y[i], z[i], res[i]]
    
    for idx,atom in enumerate(coord):
        if atom[4] in residues:
            selection.append(atom)
        
    with open("{}.com".format("".join(outputname)), "w") as ofile:
        ofile.write("#\n")
        ofile.write("\n")
        ofile.write("Generated by utilities.py\n")
        ofile.write("\n")
        ofile.write("0 1\n")
          
        for atom in range(len(selection)):
            ofile.write("\t".join(selection[atom][0:4]))
            ofile.write("\n")
          
        ofile.close()
    
    with open("{}.xyz".format("".join(outputname)), "w") as ofile:
        ofile.write("{}".format(len(selection)))
        ofile.write("\n")
        ofile.write("Generated by utilities.py\n")

        for atom in range(len(selection)):
            ofile.write("\t".join(selection[atom][0:4]))
            ofile.write("\n")
          
        ofile.close()
        
    return None


# In[6]:


def get_traj_gaussian (outputfile):
    """This function returns all geometries from a Gaussian output file."""
    
    # Define the filename (without extension)
    filename = outputfile.split('.')[0]
    
    # list of elements used to replace atomic number with atomic symbol. Dummy to shift up by 1
    elements = ['Dummy','H','He','Li','Be','B','C','N','O','F','Ne','Na','Mg','Al','Si','P',                'S','Cl','Ar','K','Ca','Sc','Ti','V','Cr','Mn','Fe','Co','Ni','Cu','Zn','Ga',                'Ge','As','Se','Br','Kr','Rb','Sr','Y','Zr','Nb','Mo','Tc','Ru','Rh','Pd','Ag',                'Cd','In','Sn','Sb','Te','I','Xe','Cs','Ba','La','Ce','Pr','Nd','Pm','Sm','Eu',                'Gd','Tb','Dy','Ho','Er','Tm','Yb','Lu','Hf','Ta','W','Re','Os','Ir','Pt','Au',                'Hg','Tl','Pb','Bi','Po','At','Rn','Fr','Ra','Ac','Th','Pa','U','Np','Pu','Am',                'Cm','Bk','Cf','Es','Fm','Md','No','Lr','Rf','Db','Sg','Bh','Hs','Mt','Ds','Rg',                'Cn','Nh','Fl','Mc','Lv','Ts','Og']
    
    # open output file, read, and close file
    with open(outputfile,"r") as input_file:
        input_lines = input_file.readlines()
        
        
    # Now extract the number of atoms and all the geometries in the output file
    # taken from each "Input orientation" statement in the output file. We use 
    # the number of atoms to decide how many line we append to the variable containing
    # all the geometries.
    natoms = None
    traj = []
    for i,line in enumerate(input_lines):
        if line.strip().startswith("NAtoms"):
            natoms = int(line.strip().split()[1])
    for i,line in enumerate(input_lines):
        if line.strip().startswith("Input orientation"):
            for j in range(natoms):
                traj.append(input_lines[i+j+5].strip())
            
    # for convenience we define a variable that contains the number of geometries in the trajectory
    ngeoms = len(traj)/natoms
    
    # Now we make the long list into a list of list, where each sublist contains one geometry
    traj = [traj[natoms*i:natoms*(i+1)] for i in range(ngeoms)]
    
    # Now we make each "line" into its own sublist
    traj = [[traj[i][j].split() for j in range(len(traj[i]))] for i in range(len(traj))]
    
    # Now we need to delete the unnecessary numbers in each sublist ()
    for i,geom in enumerate(traj):
        for j,atom in enumerate(geom):
            del(atom[0])
            del(atom[1]) # remember that due to the first deletion the index shifts by one
            
            # Now we replace the atomic number with the corresponding atomic symbol
            atom[0]  = elements[int(atom[0])]
    
    return traj


# In[7]:


def get_opt_geom_gaussian (outputfile):
    """This function writes to file the optimized geometry from a Gaussian geometry optimization"""
    
    # Define the filename (without extension)
    filename = outputfile.split('.')[0]
    
    opt_geom = get_traj_gaussian(outputfile)[-1]
    
    # Now we write the optimized geometry to file
    
    with open(filename+"_optimized.xyz","w") as f:
        f.write(str(len(opt_geom))+ "\n")
        f.write("Generated by Utilities.py\n")
        
        for atom in opt_geom:
            f.write("\t".join(atom) + "\n")
    return None


# In[8]:


def convert_com_xyz ( comfile ):
    with open(comfile,"r") as input_file:
        input_lines = input_file.readlines()
        input_file.close()
    
    a = comfile.split('.')
    a[1] = '.xyz'
    outputfilename = ''.join(a)
        
    line_list = [[] for i in range(len(input_lines))]
    for el in range(len(input_lines)):
        line_list[el] = [input_lines[el]]
        line_list[el] = line_list[el][0].split()

    coord = line_list[5:]
    for idx, el in enumerate(coord):
        if el == []:
            del coord[idx]
            

    with open(outputfilename,"w") as output:
        output.write('{}'.format(len(coord)) +  '\n')
        output.write('Generated by utilities.py' + '\n')
        for idx, atom in enumerate(coord):
            output.write('\t'.join(atom))
            output.write('\n')
        output.close()
    return None


# In[9]:


def convert_xyz_com ( xyzfile ):
    with open(xyzfile,"r") as input_file:
        input_lines = input_file.readlines()
        input_file.close()
    
    a = xyzfile.split('.')
    a[1] = '.com'
    outputfilename = ''.join(a)
    
    inputlist = [[] for i in range(len(input_lines))]
    for el in range(len(inputlist)):
        inputlist[el] = [input_lines[el]]
        
    inputlist = inputlist[2:] # Delete first two lines of xyz file
    inputlist.append([]) # Add a blank line to the end of the list (required by Gaussian)
    
    with open(outputfilename,"w") as output:
        output.write('#' + '\n')
        output.write('\n')
        output.write('Generated by utilities.py' + '\n')
        output.write('\n')
        output.write('0 1' + '\n')
        for atom in range(len(inputlist)):
            output.write('\t'.join(inputlist[atom]))
        output.close()
    return None


# In[10]:


def fetch_pdb ( pdb_code ):
    "This function downloads a pdb file to current directory. Give pdb entry code as string argument to function"
    
    dl_url = "https://files.rcsb.org/download/" + pdb_code + ".pdb"
    
    with requests.session() as sesh:
        dl_pdb = sesh.get(dl_url)
        sesh.close()
        
    if dl_pdb.status_code != requests.codes.ok:
        print("============================================================")
        print("Not able to fetch PDB file (bad request code). Did you enter a valid PDB code?")
        print("============================================================")
        sys.exit()

        
    with open("{}.pdb".format(pdb_code),"w") as outfile:
        outfile.write(dl_pdb.text)
        outfile.close()
    return


# In[11]:


def fetch_pdb_resolution ( pdb_code ):
    "Scrape for the crystal structure resolution of a given PDB entry"
    
    pdb_url = "https://www.rcsb.org/structure/" + pdb_code
    
    with requests.session() as sesh:
        pdb_page = sesh.get(pdb_url)
        sesh.close
        
    if pdb_page.status_code != requests.codes.ok:
        print("================================================================")
        print("Not able to open PDB entry page (bad request code). Did you enter a valid PDB code?")
        print("================================================================")
        sys.exit()
        
    pdb_soup = BS(pdb_page.content, "html.parser")
    res = pdb_soup.find("li", id="exp_header_0_diffraction_resolution").get_text().split(":")[1].split(u"\xa0")[1]
    print("")
    print("Resolution: {} A".format(res))
    return None


# In[12]:


def get_elapsed_time_orca ( orca_output ):
    with open(orca_output,"r") as input_file:
        input_line = input_file.readlines()
        input_file.close()
    
    return input_line[-1]


# In[13]:


def get_calc_type_orca ( orca_output ):
    "This function determines the type of calculation: geometry optimization, frequency, TS optimization, or IRC"
    with open(orca_output,"r") as input_file:
        input_lines = input_file.readlines()
        input_file.close()
        
    keywords = get_keywords_orca(orca_output)
    
#[opt, freq, ts, irc]
#[1, 0, 0] => Geometry optimization to minimum
#[1, 1, 0] => Geometry optimization to minimum and compute frequencies
#[1, 0, 1] => Geometry optimization to TS
#[1, 1, 1] => Geometry optimization to TS and compute frequencies

    calc_evaluation = [0,0,0]
    for key in keywords:
        if re.search("opt", key, re.IGNORECASE):
            calc_evaluation[0] = 1
            
        if re.search("freq", key, re.IGNORECASE):
            calc_evaluation[1] = 1
     
        if re.search("optts", key, re.IGNORECASE):
            calc_evaluation[2] = 1

    return calc_evaluation


# In[14]:


def get_keywords_orca ( orca_output ):
    "This function extracts the keywords used in an ORCA input file as a single list, each keyword as a string"
    with open(orca_output,"r") as input_file:
        input_string = input_file.read()
        input_file.close()
        
    orca_input_section = input_string[input_string.rindex("INPUT FILE"):input_string.rindex("INPUT FILE")+10000]
    orca_input_section = orca_input_section.splitlines()
    lines = [[] for i in range(len(orca_input_section))]
    for i in range(len(orca_input_section)):
        lines[i] = [orca_input_section[i]]
        
    inputfile = []
    for line in orca_input_section:
        if line.startswith("|"):
            inputfile.append(line)
            
    for i in range(len(inputfile)):
        inputfile[i] = inputfile[i].split()
        
        
    keywords = []
    for i, line in enumerate(inputfile):
        for j, el in enumerate(line, start=2):
            if el.startswith("!") is True:
                keywords.append(line[2:])
                continue
    keylist = []
    for i in keywords:
        keylist += i
    
    return keylist


# In[15]:


def get_normal_termination_orca ( orca_output ):
    "This function determines whether the calculation terminated normally"
    with open(orca_output,"r") as input_file:
        input_lines = input_file.readlines()
        input_file.close()
        
    termination = False
    if re.search("ORCA TERMINATED NORMALLY", input_lines[-2]):
        termination = True
    return termination


# In[16]:


def get_number_of_atoms_orca ( orca_output ):
    "This function extracts the total number of atoms from the orca output file"
    with open(orca_output,"r") as input_file:
        input_string = input_file.read()
        input_file.close()
    
    no_atoms = input_string[input_string.index("Number of atoms"):input_string.index("Number of atoms")+100]
    no_atoms = no_atoms.split("\n")[0].split(" ")[-1]
    return int(no_atoms)


# In[17]:


def get_number_of_geometry_cycles_orca ( orca_output ):
    "This function counts the number of geometry cycles performed in a geometry optinization"
    with open(orca_output,"r") as input_file:
        input_string = input_file.read()
        input_file.close()
        
    cycles = re.findall("GEOMETRY OPTIMIZATION CYCLE", input_string, re.DOTALL)
    return len(cycles)


# In[18]:


def get_energy_orca( orca_output ):
    "This script extracts the final optimized energy from an ORCA output file. If D3 has been added, also look for this correction"
    with open(orca_output,"r") as input_file:
        input_lines = input_file.readlines()
        input_file.close()
    
# ENERGY EVALUATION: DETERMINE WHETHER DISPERSION CORRECTION HAS BEEN USED OR NOT
#[1,0] => No empirical dispersion energy found in orca output file
#[1,1] => Impirical dispersion energy found in orca output file
    
    energy_evaluation = [1,0]
    disp_energies = []
    energies = []
    for line in input_lines:
        if line.startswith("FINAL SINGLE POINT ENERGY"):
            energies.append(line.split()[-1])
    final_energy = energies[-1]
    
    keylist = get_keywords_orca(orca_output)
    for i in keylist:
        if "d3" in keylist or "D3" in keylist or "d3bj" in keylist or "D3BJ" in keylist:
            for idx,line in enumerate(input_lines):
                if line.startswith("Dispersion correction") and input_lines[idx-1].startswith("-"):
                    disp_energies.append(line.split()[-1])
                    energy_evaluation[1] = 1
        
    return [energy_evaluation, [energies[-1], disp_energies[-1]]]


# In[19]:


def get_constrained_atoms_orca ( inputfile ):
    "Finds the constrained atoms used in an input file"
    with open(inputfile,"r") as infile:
        inlines = infile.readlines()
        infile.close()
        
    const = []
    # Identify constrained atoms lines as those lines starting with "{" (not really robust...)
    for line in inlines:
        if line.strip().startswith("{"):
            const.append(line[line.index("{")+1:line.rindex("}")].strip().split())

    const_atoms = []
    # extract the atom indeces. These numbers are one less than XYZ file index:
    # atom "0" (zero) is atom "1" in the XYZ file. But since this script will be used
    # along with the random displacement script, we don't need to shift the index by one, 
    # as Python list indeces start at zero.
    for c in const:
        if c[0] == "C":
            const_atoms.append(int(c[1]))
        elif c[0] == "B":
            const_atoms.append(int(c[1]))
            const_atoms.append(int(c[2]))
        elif c[0] == "A":
            const_atoms.append(int(c[1]))
            const_atoms.append(int(c[2]))
            const_atoms.append(int(c[3]))
        elif c[0] == "D":
            const_atoms.append(int(c[1]))
            const_atoms.append(int(c[2]))
            const_atoms.append(int(c[3]))
            const_atoms.append(int(c[4]))
        else:
            print("No constraints found")
    print(len(const_atoms))

    return const_atoms, inlines


# In[20]:


def wiggle_constraints_orca ( inputfile ):
    """This script generates a molden readable frequency file that wiggles the constrained atoms.
    Reads the input file for constraints, and then opens the xyz file used in the input. If more
    than one xyz file, it chooses by default the first one. It should not matter, unless different xyz
    files are used in the same inpubt file, which I think should be rare."""
    
    # Define the filename
    filename = inputfile.split(".")[0]
    
    # get the constraints
    const_atoms = get_constrained_atoms_orca(inputfile)[0]
    
    # Now get the name of the xyz file used in the input
    inlines = get_constrained_atoms_orca(inputfile)[1]
    xyzfile = None
    for line in inlines:
        if line.startswith("* xyzfile"):
            xyzfile = str(line.split()[4])
            break
    
    # Now open the xyzfile
    with open(xyzfile, "r") as infile:
        inlines = infile.readlines()
        infile.close()
    # Remove the top two lines (number of atoms and comment line)
    coord = inlines[2:]
    no_atoms = len(coord)
    # Now split each line into strings of its elements
    coord = [line.split() for line in coord]
    
    # Now convert coordinates to Bohr
    for line in range(no_atoms):
        for el in range(1,4):
            coord[line][el] = str(float(coord[line][el]) * float(1.8897259886))
        
    
    # Now open the wiggle file for writing
    with open("{}_wiggle.molden".format(filename), "w") as wiggle:
        wiggle.write("[MOLDEN FORMAT]\n")
        wiggle.write("[N_FREQ]\n")
        wiggle.write("1\n")
        wiggle.write("[FREQ]\n")
        wiggle.write("0.0\n")
        wiggle.write("[NATOM]\n")
        wiggle.write("{}\n".format(no_atoms))
        wiggle.write("[FR-COORD] (Angs)\n")
        for el in coord:
            wiggle.write(" ".join(el) + "\n")
        wiggle.write("[FR-NORM-COORD]\n")
        wiggle.write("vibration 1\n")
        for el in range(len(coord)):
            if el in const_atoms:
                wiggle.write("1.0 0.0 0.0\n")
            else:
                wiggle.write("0.0 0.0 0.0\n")
    wiggle.close()
    print("Wiggling written to \t {}_wiggle.molden".format(filename))
    return None


# In[117]:


def wiggle_constraints_gaussian (inputfile, xyzfile):
    """This script collects the constraint information from the modredundant section in a Gaussian input file, 
    and creates a molden normal mode file in which the constrained atoms will move. This is to double check
    that the correct constraints will be imposed before starting the optimization.
    
    It needs two inputs: input file and xyz file"""
    
    jobname = inputfile.split(".")[0]
    
    with open(inputfile, "r") as infile:
        inlines = infile.readlines()
    
    # Now we collect the constraints by looking for the string '!!! Constraints !!!'
    # This is just a comment line in the input, so this script completely depends on that string being present 
    # right above the input section
    constraints = []
    for i,line in enumerate(inlines):
        if line.strip().startswith("!!! Constraints"):
            constraints.append(inlines[i+1:])
    
    # Don't need a "double list" (list of a single list)
    constraints = constraints[0]
    
    # Remove all lines after the first occurance of an empty line (which marks the end of the
    # ModRedundant input section)
    for i,line in enumerate(constraints):
        if line == "\n":
            del constraints[i:]
    
    # Initialize new list which will contain only the indeces of constrained atoms
    indeces = []
    for line in constraints:
        if line.startswith("X"):
            indeces.append(int(line.split()[1]))
        if line.startswith("B"):
            indeces.append(int(line.split()[1]))
            indeces.append(int(line.split()[2]))
        if line.startswith("A"):
            indeces.append(int(line.split()[1]))
            indeces.append(int(line.split()[2]))
            indeces.append(int(line.split()[3]))
        if line.startswith("D"):
            indeces.append(int(line.split()[1]))
            indeces.append(int(line.split()[2]))
            indeces.append(int(line.split()[3]))
            indeces.append(int(line.split()[4]))
            
    # Now we need a geometry to put into the molden file
    
    with open(xyzfile, "r") as xyzfile:
        xyzlines = xyzfile.readlines()
        
    coord = xyzlines[2:]
    coord = [line.split() for line in coord]
    no_atoms = len(coord)
    # Now convert coordinates to Bohr
    for line in range(no_atoms):
        for el in range(1,4):
            coord[line][el] = str(float(coord[line][el]) * float(1.8897259886))
            
    # Now open the wiggle file for writing
    with open("{}_wiggle.molden".format(jobname), "w") as wiggle:
        wiggle.write("[MOLDEN FORMAT]\n")
        wiggle.write("[N_FREQ]\n")
        wiggle.write("1\n")
        wiggle.write("[FREQ]\n")
        wiggle.write("0.0\n")
        wiggle.write("[NATOM]\n")
        wiggle.write("{}\n".format(no_atoms))
        wiggle.write("[FR-COORD] (Angs)\n")
        for el in coord:
            wiggle.write(" ".join(el) + "\n")
        wiggle.write("[FR-NORM-COORD]\n")
        wiggle.write("vibration 1\n")
        for el in range(len(coord)):
            if el+1 in indeces:
                wiggle.write("1.0 0.0 0.0\n")
            else:
                wiggle.write("0.0 0.0 0.0\n")
    
    print("Wiggling written to \t {}_wiggle.molden".format(jobname))  
    return None


# In[118]:




def small_random_displacement ( xyzfile ):
    "Make small and random displacements of all atoms in xyzfile, for restarting geometry optimizations"
    filename = xyzfile.split(".")[0]
    with open(xyzfile, "r") as infile:
        inlines = infile.readlines()
        infile.close()
    
    # isolate cartesian coordinates from XYZ header
    xyz = [el.split() for el in inlines[2:]]
    
    # get the constrained atoms
    print("Do you have constrained atoms in this XYZ file? (y/n)")
    answer = raw_input()
    if answer == "n":
        const_atom = [""]
        print("No constraints given.")
    elif answer == "y":
        print("Please give name of ORCA input containing the constraints:")
        const_atom = get_constrained_atoms_orca(raw_input())[0]
        print(len(const_atom))
        print("Found {} constrained atoms to be excluded from random displacements.".format(len(const_atom)))

    for i in range(len(xyz)):
        if i in const_atom:
            continue
        else:
            for j in range(1,4):
                #xyz[i][j] = "D" ========== used for testing
                xyz[i][j] = str(float(xyz[i][j]) + random.uniform(-1,1) * 0.05)
            
    with open("{}_rand.xyz".format(filename), "w") as outfile:
        outfile.write("{}\n".format(len(xyz)))
        outfile.write("Generated by utilities.py\n")
        
        for el in xyz:
            outfile.write("\t\t".join(el))
            outfile.write("\n")
        outfile.close()
            
    return None


# In[22]:


def get_energy_change_orca ( outputfile ):
    "Extracts Delta E for geometry convergencen"
    with open(outputfile,"r") as infile:
        inlines = infile.readlines()
        infile.close()
        
    # Initialize variables to be extracted
    ec      = []
    rmsgrad = []
    maxgrad = []
    rmsstep = []
    maxstep = []
    energies = []
    tole    = None
    tolmaxg = None
    tolrmsg = None
    tolmaxd = None
    tolrmsd = None
    
    
    
    for line in inlines:
        if line.startswith("FINAL SINGLE POINT ENERGY"):
            energies.append(float(line.split()[4]))
            
        line.split(" ")
        if "  Energy change" in line:
            ec.append(float(line.strip().split()[2]))
        elif "  RMS gradient" in line:
            rmsgrad.append(float(line.strip().split()[2]))
        elif "  MAX gradient" in line:
            maxgrad.append(float(line.strip().split()[2]))
        elif "  RMS step" in line:
            rmsstep.append(float(line.strip().split()[2]))
        elif "  MAX step" in line:
            maxstep.append(float(line.strip().split()[2]))
            
    # Now make the list of gradient changes (Delta rmsg and Delta maxg)
    
    drmsg = [[] for i in range(len(rmsgrad) - 1)]
    dmaxg = [[] for i in range(len(maxgrad) - 1)]
    for i in range(len(drmsg)):
        drmsg[i] = rmsgrad[i+1] - rmsgrad[i]
        dmaxg[i] = maxgrad[i+1] - maxgrad[i]
        
    # Now extract the geometry convergence tolerances
    for i,line in enumerate(inlines):
        if line.startswith("Convergence Tolerances:"):
            tole = float(inlines[i+1].split()[4].strip())
            tolmaxg = float(inlines[i+2].split()[4].strip())
            tolrmsg = float(inlines[i+3].split()[4].strip())
            tolmaxd = float(inlines[i+4].split()[4].strip())
            tolrmsd = float(inlines[i+5].split()[4].strip())
        
    return ec, rmsgrad, maxgrad, rmsstep, maxstep, drmsg, dmaxg, tole, tolmaxg, tolrmsg, tolmaxd, tolrmsd, energies


# In[23]:


def get_no_of_scfsteps_orca ( outputfile ):
    "Extract the number of SCF cycles needed for each geometry iteration"
    
    with open(outputfile,"r") as infile:
        inlines = infile.readlines()
        infile.close()
        
        cycle = []
        
        for line in inlines:
            if "SCF CONVERGED AFTER" in line:
                cycle.append(line.strip().split("*")[1].strip().split()[3])
    return cycle


# In[24]:


def get_normalmodes_orca (hessfile):
    """This script reads a .hess file from an ORCA frequency calculation and generates
    a molden-readable file containing the normal modes"""
    
    # get the jobname (without extension). Assumes only one "." is used in the
    # filename
    jobname = hessfile.split(".")[0]
    with open(hessfile, "r") as infile:
        inlines = infile.readlines()
        infile.close()

    # Initialize some variables
    no_of_freq = None
    freqs      = []
    modes      = []
    geom       = []
    # Extract the number of frequencies and all frequencies
    for i,line in enumerate(inlines):
        
        # Now get the number of frequencies
        if line.startswith("$vibrational_frequencies"):
            no_of_freq = int(inlines[i+1])
            for j in range(no_of_freq):
                freqs.append(float(inlines[i+j+2].split()[1]))

        # Now get all normal modes
        if line.startswith("$normal_modes"):
            # index where the normal mode data starts
            start = i+3
            # the number of columns containing normal modes
            cols = len(inlines[start].split()) - 1
            # the number of times the columns are repeated
            rows = int(float(no_of_freq)/float(cols)) + 1
            # the number of columns in the last "line" of normal mode data
            rest = no_of_freq - (cols * (rows - 1))

            # minus 1 to not include the "rest" row
            for r in range(rows-1):
                # define each line where the data starts
                # i: start of normal mode section, 3: to get to where the data
                # starts, r*(nfreq+1): move down in r multiples of nfreq (must add
                # one due to the extra label line inbetween each normal mode)
                start = i + 3 + r*(no_of_freq+1)
                for c in range(cols):
                    for f in range(no_of_freq):
                        modes.append(float(inlines[start+f].split()[c+1]))

            # Now pick up the "rest" normal mode
            # move down to the last "line" of normal mode data
            start = i + 3 + (rows-1)*(no_of_freq+1)
            for r in range(rest):
                for f in range(no_of_freq):
                    modes.append(float(inlines[start + f].split()[r+1]))
        
            # Now split the normal mode data into their x, y, and z components, as
            # this will make it easier to write to file
            mode_x = modes[::3]
            mode_y = modes[1::3]
            mode_z = modes[2::3]


        # Now get the geometry
        if line.startswith("$atoms"):
            no_atoms = int(inlines[i+1])
            start = i+2
            for atom in range(no_atoms):
                for k in range(5):
                    # we do not want the "mass" column in the table, so we exclude
                    # index 1 from the loop
                    if k != 1:
                        geom.append(inlines[start+atom].split()[k])
    # Now format geom into something which is easier to write (list of lists)
    coord = [[] for i in range(no_atoms)]
    for i in range(no_atoms):
        coord[i] = geom[i*4:i*4+4]

    # Define the output name as jobname_normalmodes.molden
    output=jobname + "_normalmodes.molden"
    # Now we write all of our data to file
    with open(output, "w") as o:
        o.write("[MOLDEN FORMAT]\n")
        o.write("[N_FREQ]\n")
        o.write("{}\n".format(no_of_freq))
        o.write("[FREQ]\n")
    
        for f in freqs:
            o.write(str(f) + "\n")

        o.write("[NATOM]\n")
        o.write(str(no_atoms) + "\n")
        o.write("[FR-COORD]\n")
    
        for c in coord:
            o.write("\t".join(c) + "\n")

        o.write("[FR-NORM-COORD]\n")

        for m in range(len(modes)):
            if float(m) % no_of_freq == 0:
                o.write("vibration {}\n".format(str(m/no_of_freq + 1)))

            if float(m) % 3 == 0:
                o.write("".join(str(mode_x[m/3]) + " " + str(mode_y[m/3]) + " " + str(mode_z[m/3])) + "\n")
        o.close()
    print("Normal modes written to \t {}_normalmodes.molden".format(jobname))
    
    return None


# In[25]:


def orca_template_scaninitialhessian (  ):
    """This script generates a template input file for an ORCA linear transit scan
    where the initial Hessian calculation is done at a different level of theory
    than the optimizations themselves. ORCA do not currently offer this feature
    automatically."""
    
    print("What is the purpose of this calculation?")
    purpose = raw_input()
    
    print("Which functional do you want?")
    functional = raw_input()
    
    print("Which basis set do you want for initial Hessian?")
    basis_hess = raw_input()
    
    print("Which basis set do you want for geometry optimizations?")
    basis_gopt = raw_input()
    
    print("Do you want the CPCM model for geometry optimizations? [y/n]")
    choice_cpcm = raw_input()
    if choice_cpcm == "y":
        cpcm = 1
    elif choice_cpcm == "n":
        cpcm = 0
    else:
        sys.exit("Invalid choice! You must choose either y or n.")
    
    print("What do you want to call this input file (without extension)?")
    projname = raw_input()
    
    with open("{}.inp".format(projname), "w") as temp:
        temp.write("#####################################\n")
        temp.write("##### Generated by utilities.py \n")
        temp.write("##### Project: {}          \n".format(projname))
        temp.write("##### Author:  Anders Brakestad \n")
        temp.write("##### Date:    {}       \n".format(dt.today().strftime("%d-%m-%Y")))
        temp.write("#####################################\n")
        temp.write("\n")
        
        temp.write("# PURPOSE: {}\n".format(purpose))
        temp.write("\n")
        
        
        temp.write("################################################\n")
        temp.write("################# INITIAL HESSIAN ##############\n")
        temp.write("################################################\n")
        temp.write("!rks {} {}\n".format(functional, basis_hess))
        temp.write("!freq\n")
        temp.write("!rijcosx Grid4 GridX4 Pmodel\n")
        
        temp.write("%BASE \"init-hess\"\n")
        temp.write("\n")
        
        temp.write("%PAL\n")
        temp.write("\t NProcs 16\n")
        temp.write("END\n")
        temp.write("\n")
        
        temp.write("* xyzfile -1 1 XYZNAME\n")
        temp.write("\n")
        
        temp.write("################################################\n")
        temp.write("$new_job\n")
        temp.write("################################################\n")
        temp.write("############## GEOMETRY OPTIMIZATION ###########\n")
        temp.write("################################################\n")
        temp.write("!rks {} {} d3\n".format(functional, basis_gopt))
        temp.write("!opt slowconv\n")
        if cpcm == 1:
            temp.write("!cpcm\n")
        temp.write("!rijcosx Grid4 GridX4 MORead\n")
        temp.write("%MOINP \"init-hess.gbw\" \n")
        temp.write("\n")
        
        temp.write("%PAL\n")
        temp.write("\t NProcs 16\n")
        temp.write("END\n")
        temp.write("\n")
        
        if cpcm == 1:
            temp.write("%CPCM\n")
            temp.write("\t Epsilon 4\n")
            temp.write("END\n")
            temp.write("\n")
            
        temp.write("%SCF\n")
        temp.write("\t Convergence Tight\n")
        temp.write("\t MaxIter 350\n")
        temp.write("END\n")
        temp.write("\n")
        
        temp.write("%GEOM\n")
        temp.write("\t #TolRMSG 5e-04\n")
        temp.write("\t #TolMaxG 2e-03\n")
        temp.write("\t MaxIter 300\n")
        temp.write("\t InHess Read\n")
        temp.write("\t\t InHessName \"init-hess.hess\"\n")
        temp.write("\t Constraints\n")
        temp.write("\t End\n")
        temp.write("END\n")
        temp.write("\n")
        
        temp.write("* xyzfile -1 1 XYZNAME")
        
        temp.close()
    return None


# In[26]:


def orca_template_geometryoptimization():
    """This script generates an ORCA geometry optimization input template. DFT is assumed. You can specify
    the desireable basis set and density functional, and whether you want a CPCM model."""
    
    print("What is the purpose of this calculation?")
    purpose = raw_input()
    
    print("Which functional do you want?")
    functional = raw_input()
    
    print("Which basis set do you want?")
    basis = raw_input()
    
    print("Do you want the CPCM model? [y/n]")
    choice_cpcm = raw_input()
    if choice_cpcm == "y":
        cpcm = 1
    elif choice_cpcm == "n":
        cpcm = 0
    else:
        sys.exit("Invalid choice! You must choose either y or n.")
    
    print("What do you want to call this input file (without extension)?")
    projname = raw_input()
        
    with open("{}.inp".format(projname), "w") as temp:
        temp.write("#####################################\n")
        temp.write("##### Generated by utilities.py \n")
        temp.write("##### Project: {}          \n".format(projname))
        temp.write("##### Author:  Anders Brakestad\n")
        temp.write("##### Date:    {}       \n".format(dt.today().strftime("%d-%m-%Y")))
        temp.write("#####################################\n")
        temp.write("\n")
        
        temp.write("# PURPOSE: {}\n".format(purpose))
        temp.write("\n")
        
        temp.write("################################################\n")
        temp.write("############## GEOMETRY OPTIMIZATION ###########\n")
        temp.write("################################################\n")
        temp.write("!rks {} {} d3\n".format(functional, basis))
        temp.write("!opt slowconv\n")
        if cpcm == 1:
            temp.write("!cpcm\n")
        temp.write("!rijcosx Grid4 GridX4 Pmodel\n")
        temp.write("\n")
        
        temp.write("%PAL\n")
        temp.write("\t NProcs 16\n")
        temp.write("END\n")
        temp.write("\n")
        
        if cpcm == 1:
            temp.write("%CPCM\n")
            temp.write("\t Epsilon 4\n")
            temp.write("END\n")
            temp.write("\n")
            
        temp.write("%SCF\n")
        temp.write("\t Convergence Tight\n")
        temp.write("\t MaxIter 350\n")
        temp.write("END\n")
        temp.write("\n")
        
        temp.write("%GEOM\n")
        temp.write("\t #TolRMSG 5e-04\n")
        temp.write("\t #TolMaxG 2e-03\n")
        temp.write("\t MaxIter 300\n")
        temp.write("\t Constraints\n")
        temp.write("\t End\n")
        temp.write("END\n")
        temp.write("\n")
        
        temp.write("* xyzfile -1 1 XYZNAME")
        
        temp.close()
    return None


# In[27]:


def orca_template_frequencies():
    """This script generates an ORCA frequency calculation input template. DFT is assumed. You can specify
    the desireable basis set and density functional."""
    
    print("What is the purpose of this calculation?")
    purpose = raw_input()
    
    print("Which functional do you want")
    functional = raw_input()
    
    print("Which basis set do you want?")
    basis = raw_input()
    
    print("What do you want to call this input file (with extension)?")
    projname = raw_input()
        
    with open("{}".format(projname), "w") as temp:
        temp.write("#####################################\n")
        temp.write("##### Generated by utilities.py \n")
        temp.write("##### Project: {}          \n".format(projname))
        temp.write("##### Author:  Anders Brakestad \n")
        temp.write("##### Date:    {}       \n".format(dt.today().strftime("%d-%m-%Y")))
        temp.write("#####################################\n")
        temp.write("\n")
        
        temp.write("# PURPOSE: {}\n".format(purpose))
        temp.write("\n")
        
        temp.write("################################################\n")
        temp.write("############## FREQUENCY CALCULATION ###########\n")
        temp.write("################################################\n")
        temp.write("!rks {} {} d3\n".format(functional, basis))
        temp.write("!freq\n")
        temp.write("!rijcosx Grid4 GridX4 Pmodel\n")
        
        temp.write("%PAL\n")
        temp.write("\t NProcs 16\n")
        temp.write("END\n")
        temp.write("\n")
            
        temp.write("%SCF\n")
        temp.write("\t Convergence Tight\n")
        temp.write("\t MaxIter 350\n")
        temp.write("END\n")
        temp.write("\n")
        
        temp.write("* xyzfile -1 1 XYZNAME")
        
        temp.close()
    return None


# In[28]:


def quick_convergence_check_orca (output):

    with open(output,"r") as infile:
        print("Reaading file...")
        inlines = infile.readlines()
        print(">>>Done")
        infile.close()

    # Initialize variables of unknown length
    rmsg = []
    maxg = []
    ec   = []
    rmsd = []
    maxd = []

    # Now determine whether convergence has taken place: 1 for yes, 0 for no
    print("Checking convergence...")
    for line in inlines:
        if "  Energy change" in line:
            if line.split()[4].strip() == "NO":
                ec.append(float(0.4))
            elif line.split()[4].strip() == "YES":
                ec.append(float(1.4))
        elif "  RMS gradient" in line:
            if line.split()[4].strip() == "NO":
                rmsg.append(float(0.3))
            elif line.split()[4].strip() == "YES":
                rmsg.append(float(1.3))
        elif "  MAX gradient" in line:
            if line.split()[4].strip() == "NO":
                maxg.append(float(0.2))
            elif line.split()[4].strip() == "YES":
                maxg.append(float(1.2))
        elif " RMS step" in line:
            if line.split()[4].strip() == "NO":
                rmsd.append(float(0.1))
            elif line.split()[4].strip() == "YES":
                rmsd.append(float(1.1))
        elif "MAX step" in line:
            if line.split()[4].strip() == "NO":
                maxd.append(float(0))
            elif line.split()[4].strip() == "YES":
                maxd.append(float(1))
    print(">>>Done")

    idx_e = [i for i in range(len(ec))]
    idx   = [i for i in range(len(rmsg))]

    print("Plotting data...")
    fig, ax = plt.subplots()
    ax.plot(idx_e, ec, ".", label="Energy change")
    ax.plot(idx, rmsg, ".", label="RMS gradient")
    ax.plot(idx, maxg, ".", label="MAX gradent")
    ax.plot(idx, rmsd, ".", label="RMS step")
    ax.plot(idx, maxd, ".", label="MAX step")
    plt.ylim(-0.1, 1.5)
    legend = ax.legend(loc='upper center', fontsize='large', bbox_to_anchor=(0.5, 0.67))
    plt.show()
    
    return None


# In[29]:


def translate_xyz (xyzfile):
    
    # First get the job name (name of the xyz file)
    jobname = xyzfile.split(".")[0]
    
    # Now open the xyzfile
    with open(xyzfile, "r") as infile:
        inlines = infile.readlines()
        infile.close()
        
    # Remove the top two lines (number of atoms and comment line)
    coord = inlines[2:]
    no_atoms = len(coord)
    # Now split each line into strings of its elements
    coord = [line.split() for line in coord]
    
    # Define the XYZ coordinates of His508 Calpha from PDB ID 5HZ2 (used as reference)
    xref = float(41.023)
    yref = float(14.601)
    zref = float(56.605)
    
    print("Please give the index of the atom you want to translate: (1-indexed)")
    atomid = int(raw_input()) -1
    
    # Get the XYZ coordinates of the atom in the XYZ file to be translated
    x = float(coord[atomid][1])
    y = float(coord[atomid][2])
    z = float(coord[atomid][3])
    
    # Now compute the XYZ translations
    xtr = x - xref
    ytr = y - yref
    ztr = z - zref
    
    # Now translate each coordinate by the given value
    for atom in range(no_atoms):
        coord[atom][1] = str(float(coord[atom][1]) - xtr)
        coord[atom][2] = str(float(coord[atom][2]) - ytr)
        coord[atom][3] = str(float(coord[atom][3]) - ztr)

    # Now write translated coordiates to new file, overwriting the old file(totally safe, since
    # translation does not affect the geometry!)
    with open(jobname + "_aligned" + ".xyz", "w") as outfile:
        outfile.write("{}\n".format(no_atoms))
        outfile.write("Generated by utilities.py\n")
        
        for el in coord:
            outfile.write("\t\t".join(el))
            outfile.write("\n")
        outfile.close()
        
    print("Aligned coordinates written to {}".format("\n" + jobname + "_aligned" + ".xyz"))
    return None


# In[30]:


def make_scan_traj ( jobname, nstep ):
    finalenergies = []
    geometries = []
    
    # loop through all the output files and optimized geometries
    for i in range(1,int(nstep)+1):
        # open, read, and close the files
        with open(jobname+"{}.out".format(i), "r") as outfile:
            outlines = outfile.readlines()
            outfile.close()
        with open(jobname+"{}_optimized.xyz".format(i), "r") as coordfile:
            coordlines = coordfile.readlines()
            coordfile.close()
            
        # now the energies for each geom iteration, and then take the last one 
        # (which will be for the optimized geometry)
        e = []
        for line in outlines:
            if line.strip().startswith("FINAL SINGLE POINT ENERGY"):
                e.append(line.split()[-1])
        finalenergies.append(e[-1])
                
        # now get the optimized geometries
        natoms = int(coordlines[0].strip())
        geometries.append(coordlines[2:])
        
        
        # now we need to write the coordinates and energies to the trajectory file
        
    with open("scan.trj", "w") as output:
        for i in range(int(nstep)):
            output.write(str(natoms)+"\n")
            output.write(finalenergies[i]+"\n")
            for atom in range(natoms):
                output.write("".join(geometries[i][atom]))
    return None


# In[31]:


def displace_tsmode_gaussian (outputfile):
    jobname = outputfile.split(".")[0]
    
#########################################
    # extract the last geometry from the trajectory
    tsgeom = get_traj_gaussian(outputfile)[-1]
    natoms = len(tsgeom)

    # Save the element labels in correct order for later, and delete them from TS geomstry
    elem = []
    for line in tsgeom:
        elem.append(line[0])
        del(line[0])
        
    # Convert to floats
    tsgeom = [[float(c) for c in el] for el in tsgeom]
    # Concert to numpy array
    tsgeom = np.asarray(tsgeom)
###########################################    
    # read the output file containing the TS mode
    with open(outputfile,"r") as infile:
        inlines = infile.readlines()
    
    # Extract the TS mode
    tsmode = []
    for i,line in enumerate(inlines):
        if line.strip().startswith("Frequencies"):
            for j in range(i+5, i+5+natoms):
                tsmode.append(inlines[j].split())
            break
    
    # Delete some unnecessary elements
    for el in tsmode:
        del(el[5:])
        del(el[0:2])
    
    # Convert to floats
    tsmode = [[float(c) for c in el] for el in tsmode]
    # Convert to numpy array
    tsmode = np.asarray(tsmode)
##########################################

    # Define a step number that regulates how much the TS geometry is displaced
    # A quite small value should be used, as we want the approximated IRC to start
    # from a structure very close to the TS
    
    scale = 0.05
    
    # Calculate the forward and backward geometries
    forward  = tsgeom + scale * tsmode
    forward = forward.tolist()
    forward = [[str(c) for c in el] for el in forward]
    
    backward = tsgeom - scale * tsmode
    backward = backward.tolist()
    backward = [[str(c) for c in el] for el in backward]
    
    # Now we write the new coordinates to files
    
    with open(jobname+"_forward.xyz", "w") as f:
        f.write("{}".format(natoms) + "\n")
        f.write("Generated by Utilities.py\n")
        for i in range(natoms):
            f.write(elem[i] + "\t" + "\t".join(forward[i]) + "\n")
    
    with open(jobname+"_backward.xyz", "w") as f:
        f.write("{}".format(natoms) + "\n")
        f.write("Generated by Utilities.py\n")
        for i in range(natoms):
            f.write(elem[i] + "\t" + "\t".join(backward[i]) + "\n")
    return None

